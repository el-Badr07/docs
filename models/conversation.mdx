---
title: "Conversation Models"
description: "MongoDB-based conversation system for multi-conversation AI chat with comprehensive message management and search capabilities"
---

The Conversation Models provide a comprehensive MongoDB-based system for managing multi-conversation AI chat sessions. These models support user-scoped conversations, message persistence, conversation archiving, full-text search, and file attachment tracking with optimized database operations.

## Core Data Models

### Message

```python
class Message(BaseModel):
    """Individual chat message model."""
    id: str = Field(default_factory=lambda: str(ObjectId()))
    role: str  # 'user' or 'assistant'
    content: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

**Individual Message Structure:**

**Message Roles:**
- **user**: Messages from human users
- **assistant**: AI-generated responses from Agno agents

**Message Properties:**
- `id`: Unique ObjectId-based message identifier
- `role`: Distinguishes between user input and AI responses
- `content`: Complete message text content
- `timestamp`: UTC timestamp for chronological ordering
- **JSON Serialization**: Automatic datetime conversion for API responses

**Message Example:**
```json
{
  "id": "65a1b2c3d4e5f6789",
  "role": "user",
  "content": "Process this invoice and generate the journal entries",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Conversation

```python
class Conversation(BaseModel):
    """Conversation model for MongoDB storage."""
    id: str = Field(default_factory=lambda: str(ObjectId()))
    user_id: str
    title: str
    messages: List[Message] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    is_archived: bool = False
    metadata: Dict[str, Any] = Field(default_factory=dict)
    file_paths: Optional[List[str]] = Field(default_factory=list, description="Paths to files associated with this conversation")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

**Complete Conversation Structure:**

**Core Properties:**
- `id`: Unique conversation identifier (MongoDB ObjectId)
- `user_id`: User scope for multi-tenant isolation
- `title`: Human-readable conversation title
- `messages`: Embedded message array for full conversation history
- `created_at/updated_at`: Conversation lifecycle timestamps
- `is_archived`: Soft deletion for conversation management
- `metadata`: Extensible metadata storage for custom properties
- `file_paths`: File attachments associated with the conversation

**Conversation Example:**
```json
{
  "id": "65a1b2c3d4e5f6789",
  "user_id": "user123",
  "title": "Invoice Processing Discussion",
  "messages": [
    {
      "id": "65a1b2c3d4e5f678a",
      "role": "user",
      "content": "Process this invoice",
      "timestamp": "2024-01-15T10:30:00Z"
    },
    {
      "id": "65a1b2c3d4e5f678b", 
      "role": "assistant",
      "content": "I'll process your invoice through the 5-phase pipeline...",
      "timestamp": "2024-01-15T10:30:15Z"
    }
  ],
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:32:00Z",
  "is_archived": false,
  "metadata": {
    "processing_type": "invoice_automation",
    "file_count": 2
  },
  "file_paths": [
    "/uploads/invoice_001.pdf",
    "/uploads/receipt_002.jpg"
  ]
}
```

## Database Management

### ConversationStore

```python
class ConversationStore:
    """MongoDB store for conversations and messages."""
    
    def __init__(
        self,
        db_url: str = "mongodb://localhost:27017",
        db_name: str = "textra_chat",
        conversations_collection: str = "conversations"
    ):
        self.client = MongoClient(db_url)
        self.db: Database = self.client[db_name]
        self.conversations: Collection = self.db[conversations_collection]
        self._create_indexes()
```

**MongoDB Configuration:**
- **Database**: `textra_chat` for conversation storage
- **Collection**: `conversations` for all conversation documents
- **Connection Management**: Automatic connection pooling and retry logic
- **Index Optimization**: Performance-optimized database indexes

### Database Indexes

```python
def _create_indexes(self):
    """Create necessary indexes for optimal performance."""
    try:
        # Indexes for conversations collection
        self.conversations.create_index([("user_id", 1), ("created_at", -1)])
        self.conversations.create_index([("user_id", 1), ("is_archived", 1)])
        self.conversations.create_index("updated_at", background=True)
        self.conversations.create_index("title", background=True)
        # Text index for conversation search
        self.conversations.create_index([
            ("title", "text"),
            ("messages.content", "text")
        ], background=True)
    except Exception as e:
        print(f"Warning: Could not create indexes: {e}")
```

**Performance Optimization:**
- **User Scoping**: Compound index for user_id + created_at (most common query)
- **Archive Status**: Optimized filtering of archived conversations
- **Temporal Sorting**: Background index for conversation ordering
- **Title Search**: Fast conversation lookup by title
- **Full-Text Search**: Text index across titles and message content
- **Background Creation**: Non-blocking index creation during startup

## Conversation Management Operations

### Creating Conversations

```python
def create_conversation(self, user_id: str, title: str = "New Chat") -> str:
    """Create a new conversation and return its ID."""
    conversation_data = {
        "user_id": user_id,
        "title": title,
        "messages": [],
        "created_at": datetime.now(timezone.utc),
        "updated_at": datetime.now(timezone.utc),
        "is_archived": False,
        "metadata": {},
        "file_paths": []
    }
    
    result = self.conversations.insert_one(conversation_data)
    return str(result.inserted_id)
```

**Conversation Creation Features:**
- **User Scoping**: Every conversation is tied to a specific user
- **Default Title**: Auto-generates "New Chat" if no title provided
- **Empty State**: Starts with empty message array and metadata
- **UTC Timestamps**: Consistent timezone handling
- **ObjectId Return**: Returns string representation of MongoDB ObjectId

### Retrieving Conversations

```python
def get_conversation(self, conversation_id: str, user_id: str) -> Optional[Conversation]:
    """Get a specific conversation by ID."""
    try:
        doc = self.conversations.find_one({
            "_id": ObjectId(conversation_id),
            "user_id": user_id
        })
        
        if doc:
            # Convert MongoDB document to Conversation model
            doc["id"] = str(doc["_id"])
            del doc["_id"]
            return Conversation(**doc)
        return None
    except Exception as e:
        print(f"Error getting conversation {conversation_id}: {e}")
        return None
```

**Secure Conversation Access:**
- **User Isolation**: Always validates user_id to prevent cross-user access
- **ObjectId Conversion**: Handles MongoDB ObjectId to string conversion
- **Pydantic Validation**: Returns validated Conversation model
- **Error Handling**: Graceful handling of invalid ObjectIds or missing conversations
- **None Return**: Clear indication when conversation not found

### Listing User Conversations

```python
def list_conversations(
    self,
    user_id: str,
    include_archived: bool = False,
    limit: int = 50,
    offset: int = 0
) -> List[Conversation]:
    """List conversations for a user."""
    query = {"user_id": user_id}
    if not include_archived:
        query["is_archived"] = {"$ne": True}
    
    cursor = self.conversations.find(query).sort("updated_at", -1).skip(offset).limit(limit)
    
    conversations = []
    for doc in cursor:
        doc["id"] = str(doc["_id"])
        del doc["_id"]
        conversations.append(Conversation(**doc))
    
    return conversations
```

**Paginated Conversation Listing:**
- **User Scoping**: Only returns conversations for specified user
- **Archive Filtering**: Option to include/exclude archived conversations
- **Chronological Ordering**: Sorts by last update (most recent first)
- **Pagination Support**: Offset/limit for handling large conversation lists
- **Batch Processing**: Efficient cursor-based iteration
- **Model Validation**: Returns validated Conversation objects

## Message Management

### Adding Messages

```python
def add_message(
    self,
    conversation_id: str,
    user_id: str,
    role: str,
    content: str
) -> Optional[str]:
    """Add a message to a conversation."""
    try:
        # Create message data without pre-generating ID
        message_id = str(ObjectId())
        message_data = {
            "id": message_id,
            "role": role,
            "content": content,
            "timestamp": datetime.now(timezone.utc)
        }
        
        result = self.conversations.update_one(
            {"_id": ObjectId(conversation_id), "user_id": user_id},
            {
                "$push": {"messages": message_data},
                "$set": {"updated_at": datetime.now(timezone.utc)}
            }
        )
        
        if result.modified_count > 0:
            return message_id
        return None
    except Exception as e:
        print(f"Error adding message: {e}")
        return None
```

**Atomic Message Addition:**
- **Security**: Validates user ownership before adding messages
- **Atomic Operation**: Single database operation for message and timestamp update
- **Unique IDs**: Generates unique ObjectId for each message
- **Timestamp Consistency**: UTC timestamps for all messages
- **Conversation Update**: Updates conversation's last modified time
- **Return Value**: Returns message ID for client tracking

### Message Pagination

```python
def get_conversation_messages(
    self,
    conversation_id: str,
    user_id: str,
    limit: int = 50,
    before_message_id: Optional[str] = None
) -> List[Message]:
    """Get messages for a conversation with pagination."""
    try:
        pipeline = [
            {"$match": {"_id": ObjectId(conversation_id), "user_id": user_id}},
            {"$unwind": "$messages"},
            {"$sort": {"messages.timestamp": -1}}
        ]
        
        if before_message_id:
            # Add filter for pagination
            pipeline.append({
                "$match": {"messages.id": {"$lt": before_message_id}}
            })
        
        pipeline.append({"$limit": limit})
        pipeline.append({"$sort": {"messages.timestamp": 1}})  # Return in chronological order
        
        results = list(self.conversations.aggregate(pipeline))
        messages = []
        
        for result in results:
            message_data = result["messages"]
            messages.append(Message(**message_data))
        
        return messages
    except Exception as e:
        print(f"Error getting messages: {e}")
        return []
```

**Advanced Message Pagination:**
- **Aggregation Pipeline**: Efficient MongoDB aggregation for large conversations
- **Cursor-Based Pagination**: Uses message IDs for consistent pagination
- **Security Validation**: Ensures user has access to conversation
- **Chronological Return**: Returns messages in proper time order
- **Performance Optimization**: Limits results to prevent memory issues
- **Error Resilience**: Returns empty list on errors rather than crashing

## Conversation Lifecycle Management

### Title Management

```python
def update_conversation_title(self, conversation_id: str, user_id: str, title: str) -> bool:
    """Update conversation title."""
    try:
        result = self.conversations.update_one(
            {"_id": ObjectId(conversation_id), "user_id": user_id},
            {
                "$set": {
                    "title": title,
                    "updated_at": datetime.now(timezone.utc)
                }
            }
        )
        return result.modified_count > 0
    except Exception as e:
        print(f"Error updating conversation title: {e}")
        return False
```

### Automatic Title Generation

```python
def auto_title_conversation(self, conversation_id: str, user_id: str) -> Optional[str]:
    """Generate an automatic title based on the first few messages."""
    try:
        conversation = self.get_conversation(conversation_id, user_id)
        if not conversation or len(conversation.messages) < 2:
            return None
        
        # Get first user message for title generation
        first_user_message = None
        for msg in conversation.messages:
            if msg.role == "user":
                first_user_message = msg
                break
        
        if first_user_message:
            # Simple title generation - take first 50 chars of user message
            title = first_user_message.content.strip()
            if len(title) > 50:
                title = title[:47] + "..."
            
            # Update the title
            if self.update_conversation_title(conversation_id, user_id, title):
                return title
        
        return None
    except Exception as e:
        print(f"Error auto-titling conversation: {e}")
        return None
```

**Smart Title Generation:**
- **Content-Based**: Generates titles from first user message
- **Length Limits**: Truncates to 50 characters with ellipsis
- **User Message Priority**: Uses user input rather than AI responses
- **Validation**: Requires minimum conversation length before generation
- **Automatic Update**: Updates conversation title if generation succeeds

### Archive Management

```python
def archive_conversation(self, conversation_id: str, user_id: str) -> bool:
    """Archive a conversation."""
    try:
        result = self.conversations.update_one(
            {"_id": ObjectId(conversation_id), "user_id": user_id},
            {
                "$set": {
                    "is_archived": True,
                    "updated_at": datetime.now(timezone.utc)
                }
            }
        )
        return result.modified_count > 0
    except Exception as e:
        print(f"Error archiving conversation: {e}")
        return False

def unarchive_conversation(self, conversation_id: str, user_id: str) -> bool:
    """Unarchive a conversation."""
    try:
        result = self.conversations.update_one(
            {"_id": ObjectId(conversation_id), "user_id": user_id},
            {
                "$set": {
                    "is_archived": False,
                    "updated_at": datetime.now(timezone.utc)
                }
            }
        )
        return result.modified_count > 0
    except Exception as e:
        print(f"Error unarchiving conversation: {e}")
        return False
```

**Soft Delete Architecture:**
- **Archive State**: Uses `is_archived` flag for soft deletion
- **Reversible**: Conversations can be unarchived if needed
- **Data Preservation**: Maintains all conversation data and messages
- **Timestamp Updates**: Updates modification time on status changes
- **User Security**: Always validates user ownership

### Permanent Deletion

```python
def delete_conversation(self, conversation_id: str, user_id: str) -> bool:
    """Delete a conversation."""
    try:
        result = self.conversations.delete_one({
            "_id": ObjectId(conversation_id),
            "user_id": user_id
        })
        return result.deleted_count > 0
    except Exception as e:
        print(f"Error deleting conversation: {e}")
        return False
```

**Permanent Conversation Removal:**
- **Hard Delete**: Permanently removes conversation and all messages
- **Security Validation**: Requires user ownership verification
- **Irreversible**: No recovery possible after deletion
- **Clean Removal**: Removes all associated data and files

## Search and Discovery

### Full-Text Search

```python
def search_conversations(
    self,
    user_id: str,
    query: str,
    limit: int = 20,
    offset: int = 0
) -> List[Conversation]:
    """Search conversations by title and message content."""
    try:
        search_query = {
            "user_id": user_id,
            "$text": {"$search": query}
        }
        
        cursor = self.conversations.find(search_query).sort([
            ("score", {"$meta": "textScore"}),
            ("updated_at", -1)
        ]).skip(offset).limit(limit)
        
        conversations = []
        for doc in cursor:
            doc["id"] = str(doc["_id"])
            del doc["_id"]
            conversations.append(Conversation(**doc))
        
        return conversations
    except Exception as e:
        print(f"Error searching conversations: {e}")
        return []
```

**Advanced Search Features:**
- **Full-Text Index**: Searches across conversation titles and all message content
- **Relevance Scoring**: Uses MongoDB text search scoring for result ranking
- **User Scoping**: Only searches within user's conversations
- **Fallback Ordering**: Secondary sort by update time for consistent results
- **Pagination Support**: Handles large search result sets efficiently
- **Error Resilience**: Returns empty results rather than failing

## Connection Management

### Resource Cleanup

```python
def close(self):
    """Close MongoDB connection."""
    if self.client:
        self.client.close()
```

**Proper Resource Management:**
- **Connection Closing**: Explicitly closes MongoDB connections
- **Memory Cleanup**: Prevents connection leaks in long-running applications
- **Safe Shutdown**: Handles graceful application shutdown

## Usage Patterns

### Basic Conversation Flow

```python
# Initialize conversation store
store = ConversationStore(
    db_url="mongodb://localhost:27017",
    db_name="textra_chat"
)

# Create new conversation
conversation_id = store.create_conversation(
    user_id="user123",
    title="Invoice Processing Chat"
)

# Add user message
message_id = store.add_message(
    conversation_id=conversation_id,
    user_id="user123",
    role="user",
    content="Process my invoice please"
)

# Add AI response
response_id = store.add_message(
    conversation_id=conversation_id,
    user_id="user123", 
    role="assistant",
    content="I'll process your invoice through our 5-phase pipeline..."
)

# Auto-generate title
title = store.auto_title_conversation(conversation_id, "user123")
```

### Conversation Management

```python
# List user conversations
conversations = store.list_conversations(
    user_id="user123",
    include_archived=False,
    limit=20
)

# Search conversations
search_results = store.search_conversations(
    user_id="user123",
    query="invoice processing",
    limit=10
)

# Archive old conversation
store.archive_conversation(conversation_id, "user123")

# Clean up
store.close()
```

The Conversation Models provide a robust foundation for managing multi-user AI conversations with comprehensive message handling, search capabilities, and efficient MongoDB operations optimized for the Textra accounting automation platform. 